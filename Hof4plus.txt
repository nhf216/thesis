##################################################################
##Hof4plus.txt: This file is made to accompany Chapter 9         #
##of Nathan Fox's doctoral thesis.                               #
##                                                               #
##Save this file as Hof4plus.txt                                 #
##To use it, stay in the                                         #
##same directory, start Maple (by typing: maple <Enter> )        #
##and then type:  read Hof4plus.txt <Enter>                      #
##                                                               #
##This file depends on mapledoc.txt and nonstdhof.txt, which can #
##be found in the same online directory as this file             #
##                                                               #
##Written by Nathan Fox, Rutgers University,                     #
##fox at math dot rutgers dot edu                                #
##Version 1.0.0                                                  #
##################################################################

#Q4 enters pattern at index N+349 (348 special terms)
#Q(N+5k)=4k+N-248
#Q(N+5k+1)=4k+N+59
#Q(N+5k+2)=5k+1
#Q(N+5k+3)=3k+N+135
#Q(N+5k+4)=4k+N+68

#Q5 enters pattern at index N+322 (321 special terms)
#Q(N+6k)=5k+N-214
#Q(N+6k+1)=5k+N+22
#Q(N+6k+2)=6k+1
#Q(N+6k+3)=4k+N+99
#Q(N+6k+4)=5k+N+56
#Q(N+6k+5)=5k+N+60

#Q6 enters pattern at index N+128 (127 special terms)
#Q(N+7k)=6k+N-15
#Q(N+7k+1)=6k+N-3
#Q(N+7k+2)=7k+1
#Q(N+7k+3)=5k+N+42
#Q(N+7k+4)=6k+N-17
#Q(N+7k+5)=6k+N+1
#Q(N+7k+6)=6k+N+26

#Q7 enters pattern at index N+754 (753 special terms)
#Q(N+8k)=7k+487
#Q(N+8k+1)=7k+N+85
#Q(N+8k+2)=7k+N-429
#Q(N+8k+3)=7k+N+63
#Q(N+8k+4)=7k+N-446
#Q(N+8k+5)=7k+N+90
#Q(N+8k+6)=7k+N+96
#Q(N+8k+7)=7k+N+103

#Q8: 3088 special terms
#Q12: 2316
#Q13: 2266

read(`nonstdhof.txt`):
with(NonStdHof):

printf("%s\n\n%s\n\n%s@math.rutgers.edu\n\n%s\n\n%s\n%s\n%s\n%s\n%s\n",
    "This is Hof4plus.txt",
    "It accompanies Section 9.3 of \"An Exploration of Nested Recurrences Using Experimental Mathematics\" by Nathan Fox",
    "Please report bugs to fox",
    "The most current version of this package is available from",
    "http://github.com/nhf216/thesis/Hof4plus.txt",
    "For a list of the procedures in this package, along with their usage, type Help4plus();.",
    "For help with a specific procedure, type Help4plus(procedure_name);.",
    "For a brief description of a specific procedure, type Describe(procedure_name);.",
    "Note: This file is not referenced explcitly in the thesis itself. It was used to discover some of the results in Section 9.3, though, and it was used to generate the sequences plotted in that section."):

#mapledoc
Input:=':-Input':
Output:=':-Output':
Note:=':-Note':
__doc:=DocManager():

register(__doc, "FastDHof(d, ic, terms, {failure, largestnumber})",
    Input::"d: A positive integer, specifying how many terms ",
    "to put in the generalized Hofstadter recurrence",
    Input::"ic: A list of integers, specifiying an initial condition",
    Input::"terms: A nonnegative integer, specifying how ",
    "many terms to generate",
    Input::"failure: Should we consider weak (true) or strong ",
    "(false) death? (default is false)",
    Input::"largestnumber: Treat any number larger than ",
    "largestnumber as infinity going forward (default is infinity). ",
    "This is helpful if terms grow exponentially.",
    Output::"The first terms terms (or as many as exist if it ",
    "dies first) of the sequence generated by the recurrence ",
    "G_d(n) described in Section 9.3 ",
    "with initial conditions ic.  This procedure ",
    "is much faster than SeqQg, but it doesn't handle more general ",
    "recurrences.",
    Example::["2, [1,1], 20", "returns [1, 1, 2, 3, 3, 4, 5, 5, 6, 6, 6, 8, 8, 8, 10, 9, 10, 11, 11, 12]"],
    Example::["3, [1,2,3,4,5], 20", "returns [1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 15, 16]"]
):
FastDHof:=proc(d, ic, terms, {failure:=false, largestnumber:=infinity}) local L, n, i, TL, trm:
    L:=Array(ic):
    TL:=Array([0$d]):
    for n from nops(ic)+1 to terms do
        for i from 1 to d do
            TL[i]:=n-L[-i]:
        od:
        #TL[1]:=n-L[-1]:
        #TL[2]:=n-L[-2]:
        #TL[3]:=n-L[-3]:
        trm:=0:
        for i from 1 to d do
            if TL[i] > 0 and TL[i] < n then
                trm:=trm + L[TL[i]]:
            elif failure then
                trm:=-infinity:
            fi:
        od:
        if trm = -infinity then
            break:
        elif trm > largestnumber then
            trm:=infinity:
        fi:
        L(n):=trm:
        if trm = 0 then
            break:
        fi:
    od:
    return convert(L, list):
end:

AnalyzeGenHof:=proc(d, {N:=':-N', k:=':-k', terms:=500})
local L, h, i, QP:
    L:=SeqQg(terms, Nmin=N+1, ic=[[1..N, [], [h]]], icsym=h, rec=GetRec(refs=[seq(i, i=1..d)]), bigsymbols=[N]):
    QP:=GuessQuasipolynomial(L, ':-d'=1, n=k, m=d+1):
    if QP = FAIL then
        return FAIL:
    else
        return QP[2], nops(QP[1]):
    fi:
end:

#Help procedure
Help4plus:=getHelp(__doc):
