##################################################################
##ProveHof1thruN.txt: This file is made to accompany Chapter 9   #
##of Nathan Fox's doctoral thesis.                               #
##                                                               #
##Save this file as ProveHof1thruN.txt                           #
##To use it, stay in the                                         #
##same directory, start Maple (by typing: maple <Enter> )        #
##and then type:  read ProveHof1thruN.txt <Enter>                #
##                                                               #
##This file depends on mapledoc.txt and nonstdhof.txt, which can #
##be found in the same online directory as this file             #
##                                                               #
##Written by Nathan Fox, Rutgers University,                     #
##fox at math dot rutgers dot edu                                #
##Version 1.0.0                                                  #
##################################################################

read(`nonstdhof.txt`):
with(NonStdHof):

printf("%s\n\n%s\n\n%s@math.rutgers.edu\n\n%s\n\n%s\n%s\n%s\n%s\n%s\n",
    "This is ProveHof1thruN.txt",
    "It accompanies Section 9.1 of \"An Exploration of Nested Recurrences Using Experimental Mathematics\" by Nathan Fox",
    "Please report bugs to fox",
    "The most current version of this package is available from",
    "http://github.com/nhf216/thesis/ProveHof1thruN.txt",
    "For a list of the procedures in this package, along with their usage, type HelpProveHof();.",
    "For help with a specific procedure, type HelpProveHof(procedure_name);.",
    "For a brief description of a specific procedure, type Describe(procedure_name);.",
    "Note: This file is not referenced explcitly in the thesis itself. It was used to discover the results on p. 118, though, and N4N4_explore.txt depends on it."):

#mapledoc
Input:=':-Input':
Output:=':-Output':
Note:=':-Note':
__doc:=DocManager():

register(__doc, "FastHof(ic, terms, {failure, largestnumber})",
    Input::"ic: A list of integers, specifiying an initial condition",
    Input::"terms: A nonnegative integer, specifying how ",
    "many terms to generate",
    Input::"failure: Should we consider weak (true) or strong ",
    "(false) death? (default is false)",
    Input::"largestnumber: Treat any number larger than ",
    "largestnumber as infinity going forward (default is infinity). ",
    "This is helpful if terms grow exponentially.",
    Output::"The first terms terms (or as many as exist if it ",
    "dies first) of the sequence generated by the Hofstadter Q-",
    "recurrence with initial conditions ic.  This procedure ",
    "is much faster than SeqQg, but it doesn't handle more general ",
    "recurrences.",
    Example::["[1,1], 20", "returns [1, 1, 2, 3, 3, 4, 5, 5, 6, 6, 6, 8, 8, 8, 10, 9, 10, 11, 11, 12]"],
    Example::["[3,2,1], 20", "returns [3, 2, 1, 3, 5, 4, 3, 8, 7, 3, 11, 10, 3, 14, 13, 3, 17, 16, 3, 20]"]
):
FastHof:=proc(ic, terms, {failure:=false, largestnumber:=infinity})
description "A faster procedure than SeqQg for calculating terms of sequences that satisfy the Q-recurrence.":
local L, n, i, TL, trm:
    L:=Array(ic):
    TL:=Array([0$2]):
    for n from nops(ic)+1 to terms do
        TL[1]:=n-L[-1]:
        TL[2]:=n-L[-2]:
        #TL[3]:=n-L[-3]:
        trm:=0:
        for i from 1 to 2 do
            if TL[i] > 0 and TL[i] < n then
                trm:=trm + L[TL[i]]:
            elif failure then
                trm:=-infinity:
            fi:
        od:
        if trm = -infinity then
            break:
        elif trm > largestnumber then
            trm:=infinity:
        fi:
        L(n):=trm:
        if trm = 0 then
            break:
        fi:
    od:
    return convert(L, list):
end:

#3 mod 5, 7 mod 25, 67 mod 125, 117 mod 625
register(__doc, "ProveStuff({start, cap, terms, S, storelast, failure})",
    Input::"start: a positive integer indicating where to start ",
    "the exploration (default is 2, which is the smallest ",
    "sporadic N value)",
    Input::"cap: a positive integer indicating where to end the ",
    "exploration (default is 117, which is the largest ",
    "sporadic N value)",
    Input::"terms: a positive integer indicating how many terms ",
    "to generate while exploring each sequence (default is 100000)",
    Input::"S: a set of specific values to explore, or NULL to ",
    "explore all sporadic N values start<=N<=cap (default is NULL)",
    Input::"storelast: a nonnegative integer indicating how many ",
    "of the last terms of each sequence should be stored and ",
    "returned (default is 0)",
    Input::"failure: Should we consider weak (true) or strong ",
    "(false) death? (default is false)",
    Output::"A report about about the relevant sporadic N values (N <= 35 ",
    "or N <= 117 and one of the following: 1 mod 5, 7 mod 25, ",
    "N=67, or N=117)",
    Example::["start=50, cap=70", "returns [[51, 280], [56, 253], [57, 1001], [61, 515], [66, 278], [67, 100000]], [\"51 dies after 280 terms.\", \"56 dies after 253 terms.\", \"57 dies after 1001 terms.\", \"61 dies after 515 terms.\", \"66 dies after 278 terms.\", \"67 lives for at least 100000 terms.\"]"]
):
ProveStuff:=proc({start:=2, cap:=117, terms:=100000, S:=NULL, storelast:=0, failure:=false})
description "Analyze sporadic cases of the Hofstadter Q-recurrence with initial conditions 1 through N":
local N, i, L, ret, ret2, ret3, st:
    ret:=[]:
    ret2:=[]:
    ret3:=[]:
    for N from start to cap do
        if (S <> NULL and N in S) or S = NULL then
            #35
            if (N < 35) or
            #118
            (N mod 5 = 1) or
            #118
            (N mod 25 = 7) or
            #118
            (N = 67) or
            #118
            (N = 117) then  
                #L:=SeqQg(terms, ic=[seq(i, i=1..N)], rec=TRI_HOF):
                L:=FastHof([seq(i, i=1..N)], terms, failure):
                if nops(L) = terms then
                    st:=sprintf("%d lives for at least %d terms.", N, terms):
                    if storelast > 0 then
                        ret3:=[op(ret3), L[-storelast..]]:
                    fi:
                else
                    st:=sprintf("%d dies after %d terms.", N, nops(L)):
                fi:
                printf("%s\n", st):
                ret:=[op(ret), [N, nops(L)]]:
                ret2:=[op(ret2), st]:
            fi:
        fi:
    od:
    if storelast > 0 then
        return ret, ret2, ret3:
    else
        return ret, ret2:
    fi:
end:

UpdateFile:=proc(fil, strs) local fin, fout, outstr, strs2, i, lin, spindex:
    fin:=fopen(fil, READ):
    i:=1:
    outstr:="":
    strs2:=[op(strs), cat("x"$100, " ")]:
    spindex:=StringTools[Search](" ", strs[i]):
    while true do
        lin:=readline(fin):
        #print(lin):
        if lin = 0 then
            break:
        fi:
        if lin[..spindex] = strs2[i][..spindex] then
            lin:=strs2[i]:
            i:=i+1:
            #if i <= nops(strs) then
            spindex:=StringTools[Search](" ", strs2[i]):
            #fi:
        fi:
        outstr:=cat(outstr, sprintf("%s\n", lin)):
    od:
    fclose(fin):
    fout:=fopen(fil, WRITE):
    fprintf(fout, "%s", outstr):
    fclose(fout):
    print("Done"):
end:

ExtractMaxes:=proc(L, cap) local ret, i:
    ret:={}:
    for i from 1 to nops(L) do
        if L[i][2] = cap then
            ret:=ret union {L[i][1]}:
        fi:
    od:
    return ret:
end:

#117 lives for at least 3346939303913 terms, but seems to die after 160 more terms, meaning 118 may not actually be tight here.
#   Yeah.  The above is correct.  Difference is in the
#   fourth-to-last term, which refers to Q(118).  It refers to 3
#   here, instead of 118.  Next 2 terms are still big; they're just
#   different big terms.
#82 goes into a bunch of "special" cycles, then dies
#71 is eventually RST-like
#67 goes RST-like after doing other things for 19047817435 terms
#36 is eventually RST-like
#33 is eventually RST-like

#Help procedure
HelpProveHof:=getHelp(__doc):
